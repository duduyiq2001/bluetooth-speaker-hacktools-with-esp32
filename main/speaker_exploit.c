// summary:
// This code is an ESP-IDF application that initializes Bluetooth Classic, sets up a discovery callback, and starts device discovery.
// It filters discovered devices based on their Class of Device (CoD) and prints relevant information.
// It also includes functions to handle Bluetooth events and manage device properties.

#include "esp_bt.h"
#include "esp_bt_defs.h"
#include "esp_bt_main.h"
#include "esp_gap_bt_api.h"
#include "esp_log.h"
#include "nvs_flash.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_timer.h"
#include "cod_helper.h"
#include "avrcp_cniff.h"
#include "avrcp_util.h"
#define NUM_OF_TARGET 2
#define IF_SNIFFING 0

static const char *TAG = "BT_EXAMPLE";
char *attacking_bda_str[NUM_OF_TARGET];
uint8_t bda_count = 0;
static uint8_t can_connect = 1;

// Define states for the BT connection state machine
typedef enum {
    BT_STATE_IDLE,
    BT_STATE_DISCOVERING,
    BT_STATE_CONNECTING,
    BT_STATE_CONNECTED,
    BT_STATE_RECONNECTING
} bt_conn_state_t;

// Add these variables to track connection status
static bool is_device_connected = false;
static esp_bd_addr_t last_connected_device = {0};
static bool is_reconnect_attempt = false;
static bt_conn_state_t bt_state = BT_STATE_IDLE;
static uint32_t last_state_change_time = 0;
static uint8_t connection_attempts = 0;
static const uint8_t MAX_CONNECTION_ATTEMPTS = 3;

// Flag to track whether we should force a reset of BT stack
static bool needs_bt_stack_reset = false;
static uint32_t last_connection_attempt_time = 0;
static const uint32_t MIN_CONNECTION_INTERVAL_MS = 10000; // 10 seconds between connection attempts

// Forward declarations to resolve build errors
void cleanup_connection_resources(void);
void attempt_bt_connection(esp_bd_addr_t bda);
void reset_bt_stack(void);
void change_bt_state(bt_conn_state_t new_state);
void setup_a2dp_with_callbacks(void);

// Helper to grab a fresh label
static uint8_t get_transaction_label(void)
{
    uint8_t tl = current_transaction_label;
    current_transaction_label = (current_transaction_label + 1) & 0x0F; // wrap around 0â€“15
    return tl;
}

// Function to get the current time in milliseconds
static uint32_t get_current_time_ms(void) {
    return esp_timer_get_time() / 1000;
}

// Function to print the current state for debugging
static void print_bt_state(void) {
    char *state_str = "UNKNOWN";
    switch (bt_state) {
        case BT_STATE_IDLE: state_str = "IDLE"; break;
        case BT_STATE_DISCOVERING: state_str = "DISCOVERING"; break;
        case BT_STATE_CONNECTING: state_str = "CONNECTING"; break;
        case BT_STATE_CONNECTED: state_str = "CONNECTED"; break;
        case BT_STATE_RECONNECTING: state_str = "RECONNECTING"; break;
    }
    ESP_LOGI(TAG, "Current Bluetooth state: %s, connected: %d, time in state: %d ms", 
             state_str, is_device_connected, get_current_time_ms() - last_state_change_time);
}

// Function to change state with debugging
void change_bt_state(bt_conn_state_t new_state) {
    ESP_LOGI(TAG, "Changing state from %d to %d", bt_state, new_state);
    bt_state = new_state;
    last_state_change_time = get_current_time_ms();
    print_bt_state();
}

// Function to cleanup connection resources
void cleanup_connection_resources(void) {
    ESP_LOGI(TAG, "Cleaning up connection resources");
    
    // Cancel any ongoing discoveries
    if (bt_state == BT_STATE_DISCOVERING) {
        esp_bt_gap_cancel_discovery();
    }
    
    // If we were in connecting state, we might have leaked resources
    if (bt_state == BT_STATE_CONNECTING || bt_state == BT_STATE_RECONNECTING) {
        needs_bt_stack_reset = true;
    }
    
    // Return to idle state
    change_bt_state(BT_STATE_IDLE);
}

// Function to attempt a Bluetooth connection with proper resource management
void attempt_bt_connection(esp_bd_addr_t bda) {
    uint32_t current_time = get_current_time_ms();
    
    // Check if we need to reset the stack first
    if (needs_bt_stack_reset) {
        reset_bt_stack();
        return;
    }
    
    // Enforce minimum time between connection attempts to avoid resource exhaustion
    if (current_time - last_connection_attempt_time < MIN_CONNECTION_INTERVAL_MS) {
        ESP_LOGW(TAG, "Attempted connection too soon after previous attempt. Delaying.");
        vTaskDelay(pdMS_TO_TICKS(1000));
        return;
    }
    
    ESP_LOGI(TAG, "Attempting A2DP connection with enhanced resource management");
    
    // Make sure discovery is stopped first
    esp_bt_gap_cancel_discovery();
    
    // Store the time of this connection attempt
    last_connection_attempt_time = current_time;
    
    // Update state
    change_bt_state(BT_STATE_CONNECTING);
    
    // Attempt A2DP connection
    ESP_LOGI(TAG, "Starting A2DP connection attempt");
    esp_err_t ret = esp_a2d_sink_connect(bda);
    
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "A2DP connection request failed: %s", esp_err_to_name(ret));
        cleanup_connection_resources();
    } else {
        ESP_LOGI(TAG, "A2DP connection requested successfully");
    }
}

void your_a2dp_event_cb(esp_a2d_cb_event_t event, esp_a2d_cb_param_t *param)
{
    ESP_LOGI(TAG, "A2DP event received: %d", event);
    
    switch (event)
    {
    case ESP_A2D_PROF_STATE_EVT:
        ESP_LOGI(TAG, "A2DP profile state: %d", param->a2d_prof_stat.init_state);
        if (param->a2d_prof_stat.init_state == ESP_A2D_INIT_SUCCESS)
        {
            can_connect = 1;
            ESP_LOGI(TAG, "A2DP profile initialized successfully");
        } else {
            ESP_LOGE(TAG, "A2DP profile initialization failed: %d", param->a2d_prof_stat.init_state);
            can_connect = 0;
        }
        break;
    case ESP_A2D_CONNECTION_STATE_EVT:
        ESP_LOGI(TAG, "A2DP connection state: %d", param->conn_stat.state);
        if (param->conn_stat.state == ESP_A2D_CONNECTION_STATE_CONNECTED) {
            ESP_LOGI(TAG, "A2DP connection established");
            
            // Mark as connected and store device address
            is_device_connected = true;
            memcpy(last_connected_device, param->conn_stat.remote_bda, ESP_BD_ADDR_LEN);
            
            ESP_LOGI(TAG, "Connection successful, stopping discovery");
            change_bt_state(BT_STATE_CONNECTED);
            connection_attempts = 0;
        } else if (param->conn_stat.state == ESP_A2D_CONNECTION_STATE_DISCONNECTED) {
            ESP_LOGE(TAG, "A2DP connection failed or disconnected");
            
            // Mark as disconnected
            is_device_connected = false;
            
            // Clean up resources
            cleanup_connection_resources();
            
            // If we've tried to connect multiple times without success, schedule a stack reset
            if (connection_attempts >= 3) {
                ESP_LOGW(TAG, "Multiple connection failures, scheduling stack reset");
                needs_bt_stack_reset = true;
            }
            
            // Reset connection flag to allow reconnection attempts
            can_connect = 1;
            is_reconnect_attempt = true;
        } else if (param->conn_stat.state == ESP_A2D_CONNECTION_STATE_CONNECTING) {
            ESP_LOGI(TAG, "A2DP connecting...");
            change_bt_state(BT_STATE_CONNECTING);
        }
        break;
    case ESP_A2D_AUDIO_STATE_EVT:
        ESP_LOGI(TAG, "A2DP audio state: %d", param->audio_stat.state);
        break;
    default:
        ESP_LOGI(TAG, "A2DP event: %d", event);
        break;
    }
}

void a2dp_sink_data_cb(const uint8_t *data, uint32_t len)
{
    // No-op: required for SDK stability
}

// Function to set up A2DP with all required callbacks
void setup_a2dp_with_callbacks(void)
{
    ESP_LOGI(TAG, "Registering A2DP sink with full callbacks...");
    
    // Initialize A2DP sink
    esp_err_t ret = esp_a2d_sink_init();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to initialize A2DP sink: %s", esp_err_to_name(ret));
        return;
    }
    
    // Register A2DP callback
    ret = esp_a2d_register_callback(your_a2dp_event_cb);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to register A2DP callback: %s", esp_err_to_name(ret));
        return;
    }
    
    // Register A2DP data callback
    ret = esp_a2d_sink_register_data_callback(a2dp_sink_data_cb);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to register A2DP data callback: %s", esp_err_to_name(ret));
        return;
    }
}

void insert_in_list(char *str)
{
    // Deep-copy the string
    char *new_str = malloc(strlen(str) + 1); // +1 for '\0'
    if (!new_str)
    {
        ESP_LOGE(TAG, "Memory allocation failed");
        return; // Allocation failed
    }
    strcpy(new_str, str);
    if (bda_count < NUM_OF_TARGET)
    {
        attacking_bda_str[bda_count] = new_str;
        bda_count++;
    }
    return;
}

/**
 * @brief Checks if a string exists in a list of strings.
 * @param str The string to search for.
 * @param str_list The list of strings (NULL-terminated array).
 * @return true if found, false otherwise.
 */
int string_in_list(const char *str)
{
    if (!str)
    {
        return false; // Handle NULL inputs
    }

    for (int i = 0; i < bda_count; i++)
    {

        if (attacking_bda_str[i] != NULL && (strcmp(str, attacking_bda_str[i]) == 0))
        {
            return 1; // Match found
        }
    }

    return 0; // No match found
}
// this function is used to get the rssi value from the device properties
int get_rssi(esp_bt_gap_dev_prop_t *props, int num_props)
{
    for (int i = 0; i < num_props; i++)
    {
        if (props[i].type == ESP_BT_GAP_DEV_PROP_RSSI)
        {
            return *(int8_t *)(props[i].val);
        }
    }
    return -127; // Default invalid RSSI
}

// Reset the BT stack to resolve CCB issues
void reset_bt_stack(void) {
    ESP_LOGI(TAG, "Resetting Bluetooth stack to release resources");
    
    // First disable A2DP and AVRCP to release resources
    esp_a2d_sink_deinit();
    esp_avrc_ct_deinit();
    
    // Wait for the profiles to clean up
    vTaskDelay(pdMS_TO_TICKS(1000));
    
    // Then reinitialize
    setup_a2dp_with_callbacks();
    avrcp_init();
    
    // Reset flags
    connection_attempts = 0;
    is_reconnect_attempt = false;
    needs_bt_stack_reset = false;
    change_bt_state(BT_STATE_IDLE);
    
    ESP_LOGI(TAG, "Bluetooth stack reset complete");
}

// Update the timeout function to be more aggressive in handling CCB issues
static void check_state_timeout(void) {
    uint32_t current_time = get_current_time_ms();
    uint32_t time_in_state = current_time - last_state_change_time;
    
    // If connecting for too long, reset to idle
    if (bt_state == BT_STATE_CONNECTING && time_in_state > 5000) {
        ESP_LOGW(TAG, "Connection attempt timed out after %d ms", time_in_state);
        cleanup_connection_resources();
        
        // If we've had multiple connection timeouts, we likely need to reset the stack
        if (connection_attempts >= 2) {
            ESP_LOGW(TAG, "Multiple connection timeouts detected, scheduling stack reset");
            needs_bt_stack_reset = true;
        }
    }
    
    // If discovering for too long, reset to idle
    if (bt_state == BT_STATE_DISCOVERING && time_in_state > 15000) {
        ESP_LOGW(TAG, "Discovery timed out after %d ms", time_in_state);
        esp_bt_gap_cancel_discovery();
        change_bt_state(BT_STATE_IDLE);
    }
    
    // Check for CCB leaks - if we've had a lot of connection attempts, schedule a stack reset
    if (connection_attempts >= 5 && !is_device_connected) {
        ESP_LOGW(TAG, "Many connection attempts without success, scheduling stack reset");
        needs_bt_stack_reset = true;
        connection_attempts = 0;
    }
}

// this function is a callback function that is called when a bluetooth event occurs
void esp_bt_gap_cb(esp_bt_gap_cb_event_t event, esp_bt_gap_cb_param_t *param)
{
    ESP_LOGD(TAG, "GAP event received: %d", event);
    
    switch (event)
    {
    case ESP_BT_GAP_DISC_RES_EVT:
        if (bda_count < NUM_OF_TARGET && !is_device_connected && 
            (bt_state == BT_STATE_DISCOVERING || bt_state == BT_STATE_IDLE))
        {
            uint32_t cod = 0;
            char *name = "Unknown";

            // Parse device properties
            for (int i = 0; i < param->disc_res.num_prop; i++)
            {
                esp_bt_gap_dev_prop_t *prop = &param->disc_res.prop[i];
                // parse name
                if (prop->type == ESP_BT_GAP_DEV_PROP_BDNAME && prop->val)
                {
                    name = (char *)prop->val;
                }
                // parse cod
                else if (prop->type == ESP_BT_GAP_DEV_PROP_COD)
                {
                    cod = *(uint32_t *)(prop->val);
                }
            }
            char bda_str[18];
            snprintf(bda_str, 18, "%02x:%02x:%02x:%02x:%02x:%02x",
                     param->disc_res.bda[0], param->disc_res.bda[1],
                     param->disc_res.bda[2], param->disc_res.bda[3],
                     param->disc_res.bda[4], param->disc_res.bda[5]);

            // print device info

            if (is_audio_device(cod))
            {
                ESP_LOGI(TAG, "Found Audio Device: %s", name);
                ESP_LOGI(TAG, "address: %s", bda_str);
                ESP_LOGI(TAG, "Found Device:%s  [COD: 0x%06x, RSSI: %d]",
                         name, cod, get_rssi(param->disc_res.prop, param->disc_res.num_prop));
                print_cod_details(cod);
                
                // Only insert in list if it's not already there
                if (!string_in_list(bda_str)) {
                    insert_in_list(bda_str);
                }

                if (IF_SNIFFING)
                {
                    ESP_LOGI(TAG, "starting sniffing");
                    avrcp_sniff(param->disc_res.bda);
                }
                else if (bt_state != BT_STATE_CONNECTING && bt_state != BT_STATE_CONNECTED)
                {
                    ESP_LOGI(TAG, "starting connection");
                    if (can_connect)
                    {
                        // Only attempt connection if we haven't reached the max attempts
                        if (connection_attempts <= MAX_CONNECTION_ATTEMPTS) {
                            connection_attempts++;
                            attempt_bt_connection(param->disc_res.bda);
                        } else {
                            ESP_LOGW(TAG, "Max connection attempts reached for this device, skipping");
                            change_bt_state(BT_STATE_IDLE);
                        }
                    }
                    else
                    {
                        ESP_LOGI(TAG, "A2DP not ready yet");
                    }
                }
            }
        }
        break;
        
    case ESP_BT_GAP_AUTH_CMPL_EVT:
        ESP_LOGI(TAG, "Authentication complete with status: %d", param->auth_cmpl.stat);
        break;
        
    case ESP_BT_GAP_PIN_REQ_EVT:
        ESP_LOGI(TAG, "PIN request event - using default PIN");
        // Use default pin code "0000"
        esp_bt_pin_code_t pin_code = {0, 0, 0, 0};
        esp_bt_gap_pin_reply(param->pin_req.bda, true, 4, pin_code);
        break;
    
    // handle start/stop discovery events
    case ESP_BT_GAP_DISC_STATE_CHANGED_EVT:
        ESP_LOGI(TAG, "Discovery %s",
                 param->disc_st_chg.state == ESP_BT_GAP_DISCOVERY_STARTED ? "Started" : "Stopped");
        if (param->disc_st_chg.state == ESP_BT_GAP_DISCOVERY_STOPPED && 
            bt_state == BT_STATE_DISCOVERING) {
            change_bt_state(BT_STATE_IDLE);
        }
        break;

    default:
        break;
    }
}

void discover_devices()
{
    if (bt_state == BT_STATE_DISCOVERING) {
        ESP_LOGW(TAG, "Already in discovery mode, skipping");
        return;
    }
    
    change_bt_state(BT_STATE_DISCOVERING);
    ESP_LOGI(TAG, "Starting extended discovery...");

    // Extended inquiry (12s timeout, RSSI + COD filtering)
    esp_bt_inq_mode_t mode = ESP_BT_INQ_MODE_GENERAL_INQUIRY;
    uint8_t inquiry_len = 12; // 12 * 1.28s = ~15.36s max
    uint8_t max_devices = 3;  // Limit concurrent devices

    if (esp_bt_gap_start_discovery(mode, inquiry_len, max_devices) != ESP_OK)
    {
        ESP_LOGE(TAG, "Discovery start failed");
        change_bt_state(BT_STATE_IDLE);
        return;
    }

    vTaskDelay(5000 / portTICK_PERIOD_MS); // Wait longer than inquiry_len
    
    // Only stop discovery if we're still in discovery state
    if (bt_state == BT_STATE_DISCOVERING) {
        esp_bt_gap_cancel_discovery();
        change_bt_state(BT_STATE_IDLE);
    }
}

// Modify the bt_stack_init function to ensure proper service registration
void bt_stack_init(void)
{
    ESP_LOGI(TAG, "Initializing Bluetooth stack with AVRCP priority");
    
    // Initialize controller
    esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
    
    // Set controller mode to BT classic
    bt_cfg.mode = ESP_BT_MODE_CLASSIC_BT;
    
    // Initialize controller
    if (esp_bt_controller_init(&bt_cfg) != ESP_OK) {
        ESP_LOGE(TAG, "Controller init failed");
        return;
    }

    if (esp_bt_controller_enable(ESP_BT_MODE_CLASSIC_BT) != ESP_OK) {
        ESP_LOGE(TAG, "Controller enable failed");
        return;
    }

    // Initialize Bluedroid
    if (esp_bluedroid_init() != ESP_OK) {
        ESP_LOGE(TAG, "Bluedroid init failed");
        return;
    }

    if (esp_bluedroid_enable() != ESP_OK) {
        ESP_LOGE(TAG, "Bluedroid enable failed");
        return;
    }
    
    // Register GAP callback first
    if (esp_bt_gap_register_callback(esp_bt_gap_cb) != ESP_OK) {
        ESP_LOGE(TAG, "GAP callback register failed");
        return;
    }
    
    // Set discoverable and connectable mode
    if (esp_bt_gap_set_scan_mode(ESP_BT_CONNECTABLE, ESP_BT_GENERAL_DISCOVERABLE) != ESP_OK) {
        ESP_LOGE(TAG, "Set scan mode failed");
        return;
    }
    
    // Enable BT sniff mode for power saving
    esp_bt_sleep_enable();
    
    // Set security parameters
    esp_bt_sp_param_t param_type = ESP_BT_SP_IOCAP_MODE;
    esp_bt_io_cap_t iocap = ESP_BT_IO_CAP_IO;
    esp_bt_gap_set_security_param(param_type, &iocap, sizeof(uint8_t));
    
    ESP_LOGI(TAG, "Bluetooth stack initialized");
}

void app_main(void)
{
    // Initialize NVS
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);

    // Initialize BT stack with proper order
    if (!IF_SNIFFING) {
        // Initialize BT stack
        bt_stack_init();
        
        // Critical delay after stack init
        vTaskDelay(pdMS_TO_TICKS(1000));
        
        // Initialize AVRCP first and wait for it to be ready
        ESP_LOGI(TAG, "Initializing AVRCP first");
        avrcp_init();
        
        if (!avrcp_ready) {
            ESP_LOGE(TAG, "AVRCP was not initialized correctly, stopping");
            return;
        }
        
        // Wait to ensure AVRCP has time to fully initialize
        vTaskDelay(pdMS_TO_TICKS(2000));
        
        // Then initialize A2DP with all callbacks
        ESP_LOGI(TAG, "Now initializing A2DP");
        setup_a2dp_with_callbacks();
        
        // Longer wait for A2DP to fully initialize
        vTaskDelay(pdMS_TO_TICKS(3000));
        
        ESP_LOGI(TAG, "Bluetooth profile initialization complete");
    } else {
        bt_stack_init();
        initialize_l2cap();
    }

    // Final wait to ensure all components are stable
    vTaskDelay(pdMS_TO_TICKS(2000));
    
    ESP_LOGI(TAG, "Starting Bluetooth state machine");
    change_bt_state(BT_STATE_IDLE);
    
    uint8_t retry_count = 0;
    const uint8_t max_retries = 3; // Reduce from 5 to 3 to avoid using too many CCBs
    
    while (true) {
        // Print current state periodically for debugging
        print_bt_state();
        
        // Check for timeouts to prevent hanging in any state
        check_state_timeout();
        
        // Check if we need to reset the stack
        if (needs_bt_stack_reset) {
            reset_bt_stack();
            // Continue to next iteration after resetting
            vTaskDelay(pdMS_TO_TICKS(1000));
            continue;
        }
        
        switch (bt_state) {
            case BT_STATE_IDLE:
                // If we were previously connected, try to reconnect
                if (is_reconnect_attempt && retry_count < max_retries && last_connected_device[0] != 0) {
                    ESP_LOGI(TAG, "Attempting to reconnect to previously connected device, attempt %d/%d", 
                            retry_count + 1, max_retries);
                    
                    if (can_connect) {
                        retry_count++;
                        // Wait a bit between connection attempts
                        vTaskDelay(pdMS_TO_TICKS(3000));
                        attempt_bt_connection(last_connected_device);
                    }
                } else if (bda_count < NUM_OF_TARGET) {
                    // Reset reconnection flags if we're doing new discovery
                    is_reconnect_attempt = false;
                    retry_count = 0;
                    
                    // Start normal discovery if not connected and not reconnecting
                    discover_devices();
                }
                break;
                
            case BT_STATE_CONNECTED:
                // If connected, just wait and check connection status periodically
                ESP_LOGI(TAG, "Device connected, skipping discovery");
                vTaskDelay(pdMS_TO_TICKS(5000));
                break;
                
            case BT_STATE_CONNECTING:
            case BT_STATE_RECONNECTING:
                // In connecting state, just wait for the connection to complete or timeout
                ESP_LOGI(TAG, "Connection in progress, waiting...");
                vTaskDelay(pdMS_TO_TICKS(1000));
                break;
                
            case BT_STATE_DISCOVERING:
                // Wait for discovery to complete
                ESP_LOGI(TAG, "Discovery in progress, waiting...");
                vTaskDelay(pdMS_TO_TICKS(1000));
                break;
                
            default:
                ESP_LOGE(TAG, "Unknown state: %d", bt_state);
                change_bt_state(BT_STATE_IDLE);
                break;
        }
        
        // Add a small delay to prevent tight loop
        vTaskDelay(pdMS_TO_TICKS(300));
    }
}