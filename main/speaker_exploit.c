// summary:
// This code is an ESP-IDF application that initializes Bluetooth Classic, sets up a discovery callback, and starts device discovery.
// It filters discovered devices based on their Class of Device (CoD) and prints relevant information.
// It also includes functions to handle Bluetooth events and manage device properties.

#include "esp_bt.h"
#include "esp_bt_defs.h"
#include "esp_bt_main.h"
#include "esp_gap_bt_api.h"
#include "esp_log.h"
#include "nvs_flash.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "cod_helper.h"
#include "avrcp_cniff.h"
#include "avrcp_util.h"
#define NUM_OF_TARGET 2
#define IF_SNIFFING 0

static const char *TAG = "BT_EXAMPLE";
char *attacking_bda_str[NUM_OF_TARGET];
uint8_t bda_count = 0;
static uint8_t can_connect = 1;

// Helper to grab a fresh label
static uint8_t get_transaction_label(void)
{
    uint8_t tl = current_transaction_label;
    current_transaction_label = (current_transaction_label + 1) & 0x0F; // wrap around 0â€“15
    return tl;
}

void your_a2dp_event_cb(esp_a2d_cb_event_t event, esp_a2d_cb_param_t *param)
{
    switch (event)
    {
    case ESP_A2D_PROF_STATE_EVT:
        if (param->a2d_prof_stat.init_state == ESP_A2D_INIT_SUCCESS)
        {
            // Now A2DP is ready
            // Signal your application task to allow connect
            can_connect = 1;
            ESP_LOGI(TAG, "A2DP profile initialized successfully");
        }
        break;
    default:
        break;
    }
}
void a2dp_sink_data_cb(const uint8_t *data, uint32_t len)
{
    // No-op: required for SDK stability
}
// Initialize L2CAP subsystem
void initialize_ar2p(void)
{
    // A2DP Sink
    esp_a2d_sink_init();
    esp_a2d_register_callback(your_a2dp_event_cb);
    esp_a2d_sink_register_data_callback(a2dp_sink_data_cb);
}

void insert_in_list(char *str)
{
    // Deep-copy the string
    char *new_str = malloc(strlen(str) + 1); // +1 for '\0'
    if (!new_str)
    {
        ESP_LOGE(TAG, "Memory allocation failed");
        return; // Allocation failed
    }
    strcpy(new_str, str);
    if (bda_count < NUM_OF_TARGET)
    {
        attacking_bda_str[bda_count] = new_str;
        bda_count++;
    }
    return;
}

/**
 * @brief Checks if a string exists in a list of strings.
 * @param str The string to search for.
 * @param str_list The list of strings (NULL-terminated array).
 * @return true if found, false otherwise.
 */
int string_in_list(const char *str)
{
    if (!str)
    {
        return false; // Handle NULL inputs
    }

    for (int i = 0; i < bda_count; i++)
    {

        if (attacking_bda_str[i] != NULL && (strcmp(str, attacking_bda_str[i]) == 0))
        {
            return 1; // Match found
        }
    }

    return 0; // No match found
}
// this function is used to get the rssi value from the device properties
int get_rssi(esp_bt_gap_dev_prop_t *props, int num_props)
{
    for (int i = 0; i < num_props; i++)
    {
        if (props[i].type == ESP_BT_GAP_DEV_PROP_RSSI)
        {
            return *(int8_t *)(props[i].val);
        }
    }
    return -127; // Default invalid RSSI
}
// this function is a callback function that is called when a bluetooth event occurs
void esp_bt_gap_cb(esp_bt_gap_cb_event_t event, esp_bt_gap_cb_param_t *param)
{
    switch (event)
    {
    case ESP_BT_GAP_DISC_RES_EVT:
        if (bda_count < NUM_OF_TARGET)
        {
            uint32_t cod = 0;
            char *name = "Unknown";

            // Parse device properties
            for (int i = 0; i < param->disc_res.num_prop; i++)
            {
                esp_bt_gap_dev_prop_t *prop = &param->disc_res.prop[i];
                // parse name
                if (prop->type == ESP_BT_GAP_DEV_PROP_BDNAME && prop->val)
                {
                    name = (char *)prop->val;
                }
                // parse cod
                else if (prop->type == ESP_BT_GAP_DEV_PROP_COD)
                {
                    cod = *(uint32_t *)(prop->val);
                }
            }
            char bda_str[18];
            snprintf(bda_str, 18, "%02x:%02x:%02x:%02x:%02x:%02x",
                     param->disc_res.bda[0], param->disc_res.bda[1],
                     param->disc_res.bda[2], param->disc_res.bda[3],
                     param->disc_res.bda[4], param->disc_res.bda[5]);

            // print device info

            if (is_audio_device(cod) && !string_in_list(bda_str))
            {
                ESP_LOGI(TAG, "Found Audio Device: %s", name);

                ESP_LOGI(TAG, "address: %s", bda_str);

                ESP_LOGI(TAG, "Found Device:%s  [COD: 0x%06x, RSSI: %d]",
                         name, cod, get_rssi(param->disc_res.prop, param->disc_res.num_prop));
                print_cod_details(cod);
                // Start sniffing

                if (IF_SNIFFING)
                {
                    insert_in_list(bda_str);
                    ESP_LOGI(TAG, "starting sniffing");

                    avrcp_sniff(param->disc_res.bda);
                }
                else
                {
                    ESP_LOGI(TAG, "starting connection");
                    if (can_connect)
                    {
                        // Connect to the device
                        insert_in_list(bda_str);
                        ESP_LOGI(TAG, "Connecting to %s", bda_str);
                        esp_a2d_sink_connect(param->disc_res.bda);
                    }
                    else
                    {
                        ESP_LOGI(TAG, "A2DP not ready yet");
                    }
                }
            }
        }
        break;
    // handle start/stop discovery events
    case ESP_BT_GAP_DISC_STATE_CHANGED_EVT:
        ESP_LOGI(TAG, "Discovery %s",
                 param->disc_st_chg.state == ESP_BT_GAP_DISCOVERY_STARTED ? "Started" : "Stopped");
        break;

    default:
        break;
    }
}
// this function is used to initialize the bluetooth controller and set the discoverable and connectable mode
// it also registers the callback function for bluetooth events
// this function is called when the bluetooth controller is initialized
void initialize_bt()
{
    // Initialize controller
    esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
    if (esp_bt_controller_init(&bt_cfg) != ESP_OK)
    {
        ESP_LOGE(TAG, "Controller init failed");
        return;
    }

    if (esp_bt_controller_enable(ESP_BT_MODE_CLASSIC_BT) != ESP_OK)
    {
        ESP_LOGE(TAG, "Controller enable failed");
        return;
    }

    // Initialize Bluedroid
    if (esp_bluedroid_init() != ESP_OK)
    {
        ESP_LOGE(TAG, "Bluedroid init failed");
        return;
    }

    if (esp_bluedroid_enable() != ESP_OK)
    {
        ESP_LOGE(TAG, "Bluedroid enable failed");
        return;
    }

    // Set discoverable and connectable mode
    if (esp_bt_gap_set_scan_mode(ESP_BT_CONNECTABLE, ESP_BT_GENERAL_DISCOVERABLE) != ESP_OK)
    {
        ESP_LOGE(TAG, "Set scan mode failed");
        return;
    }

    // Register GAP callback
    if (esp_bt_gap_register_callback(esp_bt_gap_cb) != ESP_OK)
    {
        ESP_LOGE(TAG, "GAP callback register failed");
        return;
    }
}

// this function is used to start the discovery process
// it sets the inquiry mode to general inquiry and sets the inquiry length to 12 seconds
// it also sets the maximum number of devices to discover to 5
// this function is called when the discovery process is started
// it waits for 15 seconds to allow the discovery process to complete
// and then cancels the discovery process
void discover_devices()
{
    ESP_LOGI(TAG, "Starting extended discovery...");

    // Extended inquiry (12s timeout, RSSI + COD filtering)
    esp_bt_inq_mode_t mode = ESP_BT_INQ_MODE_GENERAL_INQUIRY;
    uint8_t inquiry_len = 12; // 12 * 1.28s = ~15.36s max
    uint8_t max_devices = 3;  // Limit concurrent devices

    if (esp_bt_gap_start_discovery(mode, inquiry_len, max_devices) != ESP_OK)
    {
        ESP_LOGE(TAG, "Discovery start failed");
        return;
    }

    vTaskDelay(5000 / portTICK_PERIOD_MS); // Wait longer than inquiry_len
    esp_bt_gap_cancel_discovery();
}
// this function is the main function of the application
// it initializes the NVS flash storage and the bluetooth controller
// it also starts the discovery process
void app_main(void)
{
    // Initialize NVS
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND)
    {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);

    // Initialize Bluetooth
    initialize_bt();
   
    if (!IF_SNIFFING)
    {
        avrcp_init();
        initialize_ar2p();
       
        
    }
    else{
        initialize_l2cap();
    }
    while (true)
    {
        // Start discovery
        if (bda_count < NUM_OF_TARGET)
            discover_devices();
    }
}